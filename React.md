# Первый урок

## Компонент

В реакте компонент, функциональный компонент, реакт компонент - это функция, которая возвращает HTML разметку (JSX если быть точным)

```
function App() {
  return (
    <div className="App">
      <h1>Hello, World!</h1>
      {alert(123)}
    </div>
  );
};
```

==> `{alert(123)}` - запускаем код прямо в JSX (без тега script)

JSX - расширение к JS, объединяющее JS и HTML

В компонент можно передать значения из JS. это могут быть и функции и переменные, которые исрполняться и отрендерятся в HTML.

```
function App() {
  const name = 'Вася'
  return (
    <div className="App">
      <h1>Hello, World!</h1>
      {name}
    </div>
  );
};
```

<Categories /> - С большой буквы, название функции которая возвращает компонент кода в виде JSX.
`{Sort()}` - Ещё способ вставки, менее предпочтительный

Так можно называть файлы-компоненты, содержащие reract компонент. Нужно для правильной интерпретации редактором кода:

```
file.jsx
```

## Импорт и экспорт

- чтобы экспортировать и получить доступ к содержимому компонента

```
export default <имя функции>
```

- чтобы получить то, что эскпортируем из какого либо файла

```
import <имя переменной> from 'путь до файла'
```

## Пропсы

Пропсы - это параметры функции, которая является компонентом `React`.
Чтобы передать пропсы:

```
<PizzaBlock title="Мексиканская" ptice="500" />
```

`title="Мексиканская"` - параметр, который становится частью объекта с ключем "title" и значением "Мексиканская"
`price={500}` - чтобы передать именно число, а не строку. Можно передать любой тип данных

Первый аргумент, который передается в компонент содержит объект со всеми пропсами (props)

# Третий урок

## State - состояние

Состояние в реакте - это изменение компонента при взаимодействии

## Хук useState

Таким образом создается хук состояния. Он нужен если переменная МЕНЯЕТСЯ. Если не меняется - `useState` не нужен!

```
const [pizzaCount, setPizzaCount] = useState(0);
```

- `pizzaCount` - переменная (состояние), в ней устанвливается значение useState(), в данном случае 0;
- `setPizzaCount` - функция изменения, она задает правило изменения. После исполнения этого компонент перерисовывается.

`setPizzaCount` передается в `onClick`:

```
<button onClick={** onClickAdd **} className="button button--outline button--add">
```

## Virtual DOM

Это копия DOM, которая сравнивается с DOM в браузере, находит изменения и точечно на них воздействует при взаимодействии.

# 4 УРОК

## Рендер

Рендер списка из массива строк.

```
return (
    <div className="categories">
      <ul>
        {categories.map((value, i) => { // Рендер списка из массива
          return <li onClick={() => onClickCategory(i)} className={activeIndex === i ? 'active' : ''}>
            {value}
          </li>;
        })}
      </ul>
    </div>
  );
```

- нельзя рендерить элементы без родителя
- если нужно то используется следующая конструкция:

```
return (
    <>
      <ul>
        {categories.map((value, i) => { // Рендер списка из массива
          return <li onClick={() => onClickCategory(i)} className={activeIndex === i ? 'active' : ''}>
            {value}
          </li>;
        })}
      </ul>
    </>
  );
```
* `<></>` - пустой тег, который не отрендерится (фрагмент).
* `<React.Fragement></React.Fragement>` - тоже самое

`onClick` - сюда передаем функцию установки стейта

### Генерация списков

#### Передача пропсов
```
{pizzas.map((obj) => (
              // {...obj} - если ключи такие же точно будут
              <PizzaBlock
                title={obj.title}
                price={obj.price}
                image={obj.imageUrl}
                sizes={obj.sizes}
                types={obj.types}
              />
            ))}
```
* передаем в функцию/компонент пропсы `title={obj.title}`. `title` - переменная, к которой привязывается ссылка на `obj.title`.

#### Функция-компонент, принимающая пропсы

```
function PizzaBlock({ title, price, image, sizes, types })
```
* Названия пропса должны совпадать с тем, что мы достаем

```
<ul>
          {
            //Рендерим массив типов пицц
            types.map((typeId, i) => (
              <li
                onClick={() => setActiveType(typeId)}
                className={activeType === i ? 'active' : ''}>
                {typeNames[typeId]}
              </li>
            ))
          }
        </ul>
```
* используем `.map`, чтобы пройти по всем элементам массива (чтобы создать несколько элементов)
* `onClick` - вешает слушатель события клик на элемент. По событию вызывается анонимная фукнция, которая вызовет `setActiveType`, что дает возможность вызывать её ТОЛЬКО при клике

```
const [activeType, setActiveType] = useState(0);
```
* Стейт для значения, создается для какого-либо элемента, хранит значение и меняет ео при вызове `setActiveType`. `useState(0)` устанавливает начальное значение. `setActiveType(id)` - устанавливает значение кликнутого элемента, меняет значение стейта и переключает состояние (в данном случае `calssName`)

# УРОК 5

## KEY

При генерации списков необходимо передать УНИКАЛЬНЫЙ ключ для генерации в виде следующего пропса:

```
key={id}
```
* чаще используют id или title
* использовать index плохая идея, особенно если список изменяемый

## Условный рендеринг

Успользуется условие (`open`), при выполнении которого происходит рендеринг:
```
{open && (
        <div className="sort__popup">
          <ul>
            <li className="active">популярности</li>
            <li>цене</li>
            <li>алфавиту</li>
          </ul>
        </div>
      )}
```

* `onClick={() => setOpen(!open)}` - по клику будет менять значение, что позволяет открывать/скрыать элемент
* `if` не испольузется для условного рендеринга

# УРОК 6 (бэкенда (fetch), изучаем хук useEffect)

## Бэкенд

Для реализации тестового backand используем сервис https://mockapi.io/projects. Регистрация через гитхаб.

Создаем новый проект, указываем только имя. Затем добавляем ресурс, тоже задаем только имя, структура нам подходит.

`Data` ресурса возвращает массив данных. Чтобы занести его туда, просто копируем содержимое `pizza.json`.

## Запросы

Как отправить запрос по ссылке?

```
https://653fb6cc45bedb25bfc1163e.mockapi.io/items
```

Простой `fetch` запрос. Это промис, который при выполнении возвращает объект `Response`.

```
fetch('https://653fb6cc45bedb25bfc1163e.mockapi.io/items')
    .then((res) => {
      return res.json();
    })
    .then((arr) => {
      setItems(arr)
    });
```

У респонса можно проверить статус код и `ok` (логическое значение `true` для кодов 200-299):

```
response.ok - вернёт true для кодов 200-299
response.status - вернет статус код
```

Затем ответ необходимо перобразовать в нужный нам формат:

```
response.json() - преобразует в json
```

## useEffect 

Компоненты могут иметь три состояния - отрендеренный, обновленный, удаленный. Хук useEffect позволяет отлавливать эти состояния и запускать код толкьо в случае их изменения. 

```
useEffect(() => {}, [])
```
* [] говорит, что did mount - компонент создался, и вызовет код только один раз


# УРОК 7 создаем компонент-скелетон, Подключаем React Router v6

Если компонент имеет свою папку, то в папке компонента должен быть файл index.jsx или index.js. Реакт по умолчанию будет искать его. Тогда импорт выглядит и работает следующим образом:

```
import PizzaBlock from './components/PizzaBlock';
```


`name.module.scss` - модуль css, вебпак уникализирует классы для каждого блока.

Подключение ReactRouter:
```import { BrowserRouter } from 'react-router-dom';```


`<BrowserRouter>` - браузер роут, в него оборачиваем все приложение
`<Routes>` - группа роутов
`<Route path="/" element={<Home />} />` - роут, путь которого при совпадении с путём в браузере генерит компонент Home (страницу)