# Первый урок

## Компонент

В реакте компонент, функциональный компонент, реакт компонент - это функция, которая возвращает HTML разметку (JSX если быть точным)

```
function App() {
  return (
    <div className="App">
      <h1>Hello, World!</h1>
      {alert(123)}
    </div>
  );
};
```

==> `{alert(123)}` - запускаем код прямо в JSX (без тега script)

JSX - расширение к JS, объединяющее JS и HTML

В компонент можно передать значения из JS. это могут быть и функции и переменные, которые исрполняться и отрендерятся в HTML.

```
function App() {
  const name = 'Вася'
  return (
    <div className="App">
      <h1>Hello, World!</h1>
      {name}
    </div>
  );
};
```

<Categories /> - С большой буквы, название функции которая возвращает компонент кода в виде JSX.
`{Sort()}` - Ещё способ вставки, менее предпочтительный

Так можно называть файлы-компоненты, содержащие reract компонент. Нужно для правильной интерпретации редактором кода:

```
file.jsx
```

## Импорт и экспорт

- чтобы экспортировать и получить доступ к содержимому компонента

```
export default <имя функции>
```

- чтобы получить то, что эскпортируем из какого либо файла

```
import <имя переменной> from 'путь до файла'
```

## Пропсы

Пропсы - это параметры функции, которая является компонентом `React`.
Чтобы передать пропсы:

```
<PizzaBlock title="Мексиканская" ptice="500" />
```

`title="Мексиканская"` - параметр, который становится частью объекта с ключем "title" и значением "Мексиканская"
`price={500}` - чтобы передать именно число, а не строку. Можно передать любой тип данных

Первый аргумент, который передается в компонент содержит объект со всеми пропсами (props)

# Третий урок

## State - состояние

Состояние в реакте - это изменение компонента при взаимодействии

## Хук useState

Таким образом создается хук состояния. Он нужен если переменная МЕНЯЕТСЯ. Если не меняется - `useState` не нужен!

```
const [pizzaCount, setPizzaCount] = useState(0);
```

- `pizzaCount` - переменная (состояние), в ней устанвливается значение useState(), в данном случае 0;
- `setPizzaCount` - функция изменения, она задает правило изменения. После исполнения этого компонент перерисовывается.

`setPizzaCount` передается в `onClick`:

```
<button onClick={** onClickAdd **} className="button button--outline button--add">
```

## Virtual DOM

Это копия DOM, которая сравнивается с DOM в браузере, находит изменения и точечно на них воздействует при взаимодействии.

# 4 УРОК

## Рендер

Рендер списка из массива строк.

```
return (
    <div className="categories">
      <ul>
        {categories.map((value, i) => { // Рендер списка из массива
          return <li onClick={() => onClickCategory(i)} className={activeIndex === i ? 'active' : ''}>
            {value}
          </li>;
        })}
      </ul>
    </div>
  );
```

- нельзя рендерить элементы без родителя
- если нужно то используется следующая конструкция:

```
return (
    <>
      <ul>
        {categories.map((value, i) => { // Рендер списка из массива
          return <li onClick={() => onClickCategory(i)} className={activeIndex === i ? 'active' : ''}>
            {value}
          </li>;
        })}
      </ul>
    </>
  );
```
* `<></>` - пустой тег, который не отрендерится (фрагмент).
* `<React.Fragement></React.Fragement>` - тоже самое

`onClick` - сюда передаем функцию установки стейта

### Генерация списков

#### Передача пропсов
```
{pizzas.map((obj) => (
              // {...obj} - если ключи такие же точно будут
              <PizzaBlock
                title={obj.title}
                price={obj.price}
                image={obj.imageUrl}
                sizes={obj.sizes}
                types={obj.types}
              />
            ))}
```
* передаем в функцию/компонент пропсы `title={obj.title}`. `title` - переменная, к которой привязывается ссылка на `obj.title`.

#### Функция-компонент, принимающая пропсы

```
function PizzaBlock({ title, price, image, sizes, types })
```
* Названия пропса должны совпадать с тем, что мы достаем

```
<ul>
          {
            //Рендерим массив типов пицц
            types.map((typeId, i) => (
              <li
                onClick={() => setActiveType(typeId)}
                className={activeType === i ? 'active' : ''}>
                {typeNames[typeId]}
              </li>
            ))
          }
        </ul>
```
* используем `.map`, чтобы пройти по всем элементам массива (чтобы создать несколько элементов)
* `onClick` - вешает слушатель события клик на элемент. По событию вызывается анонимная фукнция, которая вызовет `setActiveType`, что дает возможность вызывать её ТОЛЬКО при клике

```
const [activeType, setActiveType] = useState(0);
```
* Стейт для значения, создается для какого-либо элемента, хранит значение и меняет ео при вызове `setActiveType`. `useState(0)` устанавливает начальное значение. `setActiveType(id)` - устанавливает значение кликнутого элемента, меняет значение стейта и переключает состояние (в данном случае `calssName`)

# УРОК 5

## KEY

При генерации списков необходимо передать УНИКАЛЬНЫЙ ключ для генерации в виде следующего пропса:

```
key={id}
```
* чаще используют id или title
* использовать index плохая идея, особенно если список изменяемый

## Условный рендеринг

Успользуется условие (`open`), при выполнении которого происходит рендеринг:
```
{open && (
        <div className="sort__popup">
          <ul>
            <li className="active">популярности</li>
            <li>цене</li>
            <li>алфавиту</li>
          </ul>
        </div>
      )}
```

* `onClick={() => setOpen(!open)}` - по клику будет менять значение, что позволяет открывать/скрыать элемент
* `if` не испольузется для условного рендеринга